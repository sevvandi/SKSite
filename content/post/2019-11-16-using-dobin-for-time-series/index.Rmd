---
title: Using dobin for time series data
author: Sevvandi Kandanaarachchi
date: '2019-11-16'
slug: dobin-for-time-series
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2019-11-16T18:21:40+11:00'
featured: ''
image:
  caption: ''
  focal_point: ''
  preview_only: yes
projects: []
---
The R package *dobin* can be used as a dimension reduction tool for outlier detection. So, if we have a dataset of $N$ independent observations,  where each observation is of dimension $p$, *dobin* can be used to find a new basis, such that the outliers of this dataset are highlighted using fewer basis vectors (see [here](https://sevvandi.github.io/dobin/index.html)). 

But, how do we use *dobin* for time series data? *Dobin* is not meant for  raw time series data because it is time-dependent. But we can break a time series into consecutive non-overlapping windows and compute features of data in each window using an R package such as [*tsfeatures*](https://pkg.robjhyndman.com/tsfeatures/). If we compute $d$  features, then data in each time series window will be denoted by a point in $\mathbb{R}^d$. 

Let's look at an example. We make a normally distributed time series of length $6000$ and  insert an outlier at the position $1010$.

```{r setup, message=FALSE}
knitr::opts_chunk$set(cache=TRUE)
library(tsfeatures)
library(dplyr)
library(dobin)
library(ggplot2)

set.seed(1)
# Generate 6000 random normally distributed points for a time series
y <- rnorm(6000)
# Insert an additive outlier at position 1010
y[1010] <- 6
df <- cbind.data.frame(1:6000, y)
colnames(df) <- c("Index", "Value")
ggplot(df, aes(Index, Value)) + geom_point() + theme_bw()
```

Now, let us break the time series into non-overlapping chunks of length $50$, i.e. we get $120$ chunks or windows. Note that we need the time series to have a decent length to compute features.  For each window we compute time series features using *tsfeatures*.

```{r tsf, message=FALSE}
# Split the time series into windows of length 50
my_data_list <- split(y, rep(1:120, each = 50))
# Compute features of each chunk using tsfeatues
ftrs <- tsfeatures(my_data_list)
head(ftrs)
```

Next we input these time series features to *dobin*. 
```{r dobin, message=FALSE}
ftrs %>% dobin(norm=2) -> out
coords <- as.data.frame(out$coords[ ,1:2])
colnames(coords) <- c("DC1", "DC2")
ggplot(coords, aes(DC1, DC2)) + geom_point() + theme_bw()
```
In the first and second dobin component space (DC1-DC2 space), we see a point appearing far away near $(15, -5)$. Let's investigate this point.

```{r analysis1, message=FALSE}
inds <- which(coords[ ,1] > 10)
inds
```
OK, this point is coming from window `r inds`.  Also, this point deviates in the DC1 axis. So, let us look at the first dobin vector. 
```{r analysis2, message=FALSE}
# First dobin vector
out$vec[ ,1]
colnames(ftrs)
```
The first vector has a high value in **spike** (`r out$vec[5,1]`), which measures the amount of spikiness in a time series. Now, let's have a look at the 21st window of the time series. 

```{r analysis3, message=FALSE}
# Make a dataframe from window 21
df2 <- cbind.data.frame((1000 + 1:50), my_data_list[[inds]])
colnames(df2) <- c("Index", "Value")
ggplot(df2, aes(Index, Value)) + geom_point() + geom_line() + theme_bw()
```
We see that we've picked up the spike corresponding to position $1010$, in the 21st window, because $1010/50 = 20.2$.


So, in summary *dobin* can be used as a dimension reduction technique for outlier detection for time series data,  as long as the data is prepared appropriately. 